\documentclass[a4paper,9pt]{article}

\input{library.tex}

\begin{document}

Au cours de cette section, nous allons définir un algorithme permettant d'obtenir une
$2$-dual-approximation du problème \unitfisched{}. 

\section{Unalgorithme d'approximation}

Avant de présenter le principe général de l'algorithme, nous introduirons quelques notions
nécessaires à la compréhension de ce dernier.

\subsection{Quelques définitions}

\begin{ndf}[Une \tphase{}]
    Une \tphase{} d'un ensemble de tâches est un groupe de tâches telles que pour toutes les tâches
    appartenant à une même \tphase{} l'exécution commence au même instant et telles que deux tâches
    appartiennent à une \tphase{} différente si et seulement si elles ne s'exécutent pas en même
    temps.

    S'il existe une partition de l'ensemble des tâches en \tphase{}s, l'ordonnancement est alors dit
    \emph{par phases}.
\end{ndf}

\begin{nprop}
    Toute instance du problème \unitfisched{} donne lieu à un ordonnancement par phases.
\end{nprop}

% TODO Preuve

\begin{ndf}[Trous à gauche et à droite au temps $i$]
    Soit $M_j \in \mathcal{M}$ une machine quelconque, soit $T_{M_j}$ la dernière tâche ordonnancée
    sur la machine $M_j$ telle que $\st{T_j} <= i$ et soit $R_{M_j}$ la première réservation
    affectéé à la machine $M_j$ telle que $\sres{R_j} >= i$. On définit alors le \emph{trou à gauche
    de $M_j$ au temps $i$} (respectivement \emph{le trou à droite de $M_j$ au temps $i$}), l'écart
    entre la fin (respectivement le début) d'exécution de la tâche $T_{M_j}$ (respectivement de la
    réservation $R_{M_j}$) et le temps $i$ (respectivement $i+1$).

    Un exemple de trou à gauche (respectivement à droite) est donné par le trou $h_1$
    (respectivement $h_2$) de la figure~\ref{fig:tagtad}.
\end{ndf}

\begin{ndf}[Machine \authmach{k} au temps $i$]
    Une machine $M_j$ est dite \authmach{k} au temps $i$ si et seulement si ses trous à gauche et à
    droite ont une longueur au moins égale à $k$.

    Quelques exemples sont donnés à la figure~\ref{fig:kdisp}, au temps $6$ : 
    \begin{itemize}
        \item $M_1$ est \authmach{1}
        \item $M_2$ est \authmach{3}
        \item $M_3$ est \authmach{5}
        \item $M_4$ est \authmach{\infty}
    \end{itemize}
\end{ndf}

\begin{figure}
    \centering
    \begin{ordo}[10]{1}{1}{12}
        \newtask{1}{1}{0}{$T_{M_1}$}
        \newlabeledresa{1}{1}{10}{$R_{M_1}$}
        \newhole{3}{1}{1}{$h_1$}
        \newhole{5}{1}{5}{$h_2$}
    \end{ordo}
    \caption{Trou à gauche et à droite au temps $4$}
    \label{fig:tagtad}
\end{figure}

\begin{figure}
    \centering
    \begin{ordo}[10]{4}{1}{12}
        \newtask{1}{1}{4}{$T_{M_1}$}
        \newlabeledresa{1}{1}{8}{$R_{M_1}$}

        \newhole{1}{1}{5}{$h_1$}
        \newhole{1}{1}{7}{$h_2$}

        \newtask{1}{2}{0}{$T_{M_2}$}
        \newlabeledresa{1}{2}{10}{$R_{M_2}$}

        \newhole{5}{2}{1}{$h_3$}
        \newhole{3}{2}{7}{$h_4$}

        \newlabeledresa{1}{3}{12}{$R_{M_3}$}
        \newbeghole{6}{3}{$h_5$}
        \newhole{5}{3}{7}{$h_6$}

        \newbeghole{6}{4}{$h_7$}
        \newendhole{5}{4}{7}{$h_8$}
    \end{ordo}
    \caption{Illustration des machines \authmach{k}s}
    \label{fig:kdisp}
\end{figure}

\subsection{Principe de l'algorithme}



%Étant donné un entier $\omega$, l'algorithme proposé réalise les étapes suivantes :
%\begin{enumerate}
%    \item l'ensemble de tâches est partitionné en \nbphase{} \tphase{}s,
%    \item les \tphase{}s sont triées par date de début croissant, et parcourues dans cet ordre,
%    \item l'ensemble des machines \authmach{\frac{\omega}{2}} au temps $0$ est calculé et sera
%        maintenu tout au long du parcours. L'ensemble des machines \authmach{\frac{\omega}{2}} au
%        temps $i$ est noté $\mathcal{M}_i$,
%    \item les tâches à ordonnancer au temps $i$ sont ordonnancées sur les machines appartenant à
%        $\mathcal{M}_i$, ayant le plus petit trou à droite.
%\end{enumerate}
%
%L'algorithme s'arrête alors une fois que la dernière tâche a été ordonnancée ou sià un moment donné
%au cours de son exécution, $\mathcal{M}_i = \emptyset$ et le nombre de tâches restant à ordonanncer
%à l'instant $i$ est non nul.
%
\end{document}
