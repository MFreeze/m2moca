\documentclass[a4paper,11pt]{article}

\input{library}

\begin{document}
% Page de garde <<<
\input{page_garde}
% >>>
\newpage
\tableofcontents
\newpage

\section{Introduction}

La théorie de l'ordonnancement est une branche non négligeable de l'informatique couvrant un très
grand nombre de problèmes permettant la modélisation d'applications pratiques. Ainsi, des
problématiques aussi diverses que la planification de prises de photographies par satellite,
l'agencement spatial de marchandises dans un entrepôt ou la planification d'une chaîne de production
peuvent être représentées à l'aide de ces problèmes informatiques. Il n'est donc pas étonnant de
de disposer à ce sujet d'une littérature fournie, détaillant nombre de déclinaisons de problèmes
considérés classiques. Cette étude bibliographique, préliminaire au stage, s'inscrit dans cette
démarche et cherche à définir le contexte et les bases nécessaires à l'introduction d'une variante
d'un problème d'ordonnancement très étudié que l'on appelle \isched.

\subsection{Description des problèmes d'ordonnancement}

Nous utiliserons au cours de cette partie les notations communément utilisées pour définir de
manière générale les problèmes d'ordonnancement. Nous serons amenés à définir et utiliser des
notations plus spécifiques au problème considéré.

D'ordinaire, les problèmes d'ordonnancement sont définis par un ensemble de $n$ tâches $\mathcal{T} =
\{T_1, T_2, \dots, T_n\}$ et par un ensemble de $m$ processeurs\footnote{On les appelle aussi des
machines.} $\mathcal{P} = \{\pi_1, \pi_2, \dots, \pi_m\}$. L'ordonnancement consiste à affecter les
tâches $\mathcal{T}$ aux processeurs $\mathcal{P}$ tout en respectant les contraintes définies par
le problème initial. On peut citer deux contraintes largement répandues dans la théorie de
l'ordonnancement :
\begin{enumerate}
    \item chaque processeur peut exécuter au plus une seule tâche à tout instant,
    \item chaque tâche est exécutée par au plus un processeur.
\end{enumerate}

Il paraît important de notifier, qu'il existe des problèmes autorisant l'exécution d'une tâche sur
plusieurs processeurs, la durée d'exécution de la tâche est alors proportionnelle au nombre de
processeurs sur lesquels elle s'exécute. On parle alors de modèles hiérarchiques, mais ces modèles
ne seront pas développés dans le reste de ce manuscrit.

\subsection{Caractérisation des processeurs}

Dans le but de décrire un problème d'ordonnancement, il est important de définir l'environnement des
processeurs, c'est à dire les hypothèses considérées sur les machines. Au cours de ce rapport, seul
le modèle des processeurs parallèles, exécutant tous les mêmes fonctions, sera considéré. Pour la
découverte du modèle des processeurs dédiés, spécialisés dans l'exécution de certaines fonctions,
nous invitons les intéressés à la lecture du livre~\cite{blazewicz_handbook_2007}.

Les processeurs parallèles se décomposent en trois catégories :
\begin{enumerate}
    \item identiques : tous les processeurs de $\mathcal{P}$ admettent la même vitesse de traitement
    \item uniformes : les vitesses de traitement diffèrent mais la vitesse de traitement est
        proportionnelle à un coefficient propre à chaque machine appelé facteur d'accélération
    \item généraux : les vitesses de traitement dépendent des tâches à effectuer
\end{enumerate}

À nouveau nous ne considérerons qu'une seule catégorie, les problèmes nous intéressant ne portent
que sur des processeurs identiques.

\subsection{Caractérisation des tâches}

Généralement, en ordonnancement, une tâche est définie par cinq paramètres :
\begin{enumerate}
    \item un vecteur de temps d'exécution $p_j = ^t(p_{j1}, p_{j2}, \dots, p_{jm})$ où $p_{ji}$
        représente le temps nécessaire à l'exécution de la tâche $j$ sur la machine $i$. Dans le cas
        de machines identiques et uniformes, ce vecteur ne présente qu'une seule composante,
    \item une date de disponibilité $r_j$, désignant la date à partir de laquelle la tâche est prête
        à être exécutée,
    \item une date d'échéance $d_j$, désignant la date souhaitée à laquelle la tâche $j$ devrait
        être exécutée,
    \item une date de fin impérative$\widetilde{d_j}$, date à laquelle la tâche doit obligatoirement être exécutée,
    \item un poids $w_j$, représentant l'urgence relative de la tâche.
\end{enumerate}

Les tâches ainsi définies peuvent être soumises à certaines contraintes, telles que des contraintes
de précédence, imposant que la date d'exécution d'une exécution soit ultérieure à la complétion
d'un ensemble de tâches tierces.

Si l'on considère le graphe, que nous appellerons le graphe d'exclusion, qui à chaque tâche associe
un sommet, et tel qu'il existe une arête entre deux sommets si deux taches ne peuvent être affectée
à la même machine, il est alors possible d'imposer des contraintes structurelles à ce graphe. 

\subsection{Notation à trois champs}

La multitude de problèmes d'ordonnancement énoncée précédemment a conduit à la mise en place d'une
notation synthétique permettant la description de ces schémas. Nous nous proposons de reprendre la
notation introduite par Graham~\cite{graham} et B\l a\.zewicz~\cite{blazewicz}. 

Pour cette notation, il nous faut introduire trois paramètres $\alpha, \beta, \gamma$. Détaillons
ces paramètres :
\begin{enumerate}
    \item le paramètre $\alpha$ permet de caractériser l'environnement des processeurs. $\alpha \in
        \left\{ P, \bar{P}, P_m, Q, R \right\}$, avec :
        \begin{itemize}
            \item $P$ : les processeurs sont identiques et leur nombre est une entrée du problème,
            \item $\bar{P}$ : les processeurs sont identiques, mais leur nombre est dit suffisant ou
                non borné,
            \item $P_m$ : les processeurs sont identiques et leur nombre est fixé,
            \item $Q$ : les processeurs sont uniformes
            \item $R$ : les processeurs dont généraux
        \end{itemize}
    \item le paramètre $\beta$ permet de définir le type d'application et ses caractéristiques
        telles que les contraintes de précédence ou les durées d'exécution des tâches. Nous écrirons
        ce paramètre sous la forme $\beta = \beta_1\beta_2\beta_3$ avec :
        \begin{itemize}[label=$\bullet$]
            \item $\beta_1$ représentant les contraintes de précédence :
                \begin{itemize}
                    \item $\beta_1 = prec$ : le graphe de précédence est un graphe quelconque
                    \item $\beta_1 = arbre$ : le graphe de précédence est un arbre
                    \item[$\vdots$]
                    \item $\beta_1 = .$ : les tâches sont indépendantes
                \end{itemize}
            \item $\beta_2$ représentant les temps d'exécution des tâches :
                \begin{itemize}
                    \item $\beta_2 = p_j = 1$ : les tâches sont unitaires, leur durée est égale à
                        $1$
                    \item $\beta_2 = .$ : les durées des tâches sont données par le graphe
                \end{itemize}
            \item $\beta_3$ représentant les propriétés structurelles du graphe d'exclusion :
                \begin{itemize}
                    \item $\beta_3 = inter$ : le graphe d'exclusion est un graphe d'intervalles
                    \item $\beta_3 = .$ : le graphe d'exclusion est un graphe vide (sans arêtes)
                \end{itemize}
        \end{itemize}
    \item le paramètre $\gamma$ représente quant à lui définit la fonction objectif que l'on
        cherchera à optimiser.
\end{enumerate}

\subsection{Motivations}

Les problèmes considérés tout au long de ce rapport s'inscrivent dans la branche de l'ordonnancement
appelée \isched, dans cette branche le début et la fin de chaque tâche $j$ sont
fixés, la tâche est donc représentable par un intervalle $\left[ \st{j}, \ct{j} \right]$ et un poids
$w_j$. 

Il est usuel, pour cette catégorie de problème,  de considérer un ensemble de tâches tel qu'il est
impossible de pouvoir assigner à chaque tâche une machine, l'optimisation se fait alors en
maximisant le poids de l'ensemble des tâches affectées à une machine.

Le but de ce stage est d'étudier une nouvelle fonction objectif pour ces problèmes cherchant à
optimiser la flexibilité de l'ordonnancement produit en minimisant la fragmentation de
l'ordonnancement produit.


\newpage
\section{État de l'art}

Au cours de cette section nous présenterons, dans un premier temps, le problème \bisched ainsi qu'un
certain nombre de résultats sur ce dernier. Puis nous introduirons quelques unes des nombreuses
variantes de ce problème et là aussi nous décrirons quelques résultats que l'on peut trouver dans la
littérature. Ces problèmes ont été choisis pour les similitudes qu'ils présentent avec le problème
étudié.

\subsection{Le problème \bisched}

Étant donnés un ensemble de $n$ tâches $\mathcal{T} = \left\{
j_1, j_2, \dots, j_n \right\}$ représentés par un ensemble de $n$ intervalles $\mathcal{I} = \{
[ \st{j_1}, \ct{j_1} ], [ \st{j_2}, \ct{j_2} ], \dots, [ \st{j_n},
\ct{j_n} ] \}$ avec $\ct{j_i} > \st{j_i}$ pour $i = 1, \dots, n$, et un ensemble de
machines $\mathcal{M} = \left\{ m_1, m_2, \dots, m_k \right\}$, le but est alors de trouver un
ordonnancement minimisant le nombre de machines utilisées par ce dernier.

On peut définir la notation à trois champs de ce problème :
\begin{center}
    $\bar{P} \Big| . . inter \Big| \min \#(\mathcal{M})$
\end{center}

Ce problème, comme tous les autres problèmes d'\isched, est fortement lié à la notion de graphe
d'intervalles. Un graphe d'intervalles est un graphe tel que ses sommets sont représentables par
des intervalles et il existe une arête entre deux sommets si et seulement si les intervalles
associés à ces sommets s'intersectent lorsqu'ils sont représenté sur la ligne des réels. Un exemple
de graphe d'intervalles est donné à la
figure~\ref{fig:ex_gint}. Il est facile de voir que si l'on considère le graphe représentant les
tâches qui ne peuvent s'exécuter sur la même machine, on obtient alors un graphe d'intervalle.

\begin{figure}
    \centering
    \begin{tikzpicture}[noeud/.style={draw=black, circle}, scale=0.6, every node/.style={transform shape}]
        \draw[-] (0,  0) to node[above] {$A : [0,4]$} (5,0);
        \draw[-] (1, -2) to node[above] {$B : [1,3]$} (3,-2);
        \draw[-] (2, -1) to node[above] {$C : [2, 10]$} (10, -1);
        \draw[-] (4, -2) to node[above] {$D : [4, 9]$} (9, -2);
        \draw[-] (6,  0) to node[above] {$E : [6,7]$} (7,0);
        \draw[-] (8,  0) to node[above] {$F : [8,12]$} (12,0);
        \draw[-] (11, -1) to node[above] {$G : [11, 13]$} (13, -1);

        \node[noeud] (A) at (2, -4) {$A$};
        \node[noeud] (B) at (0, -7) {$B$};
        \node[noeud] (C) at (4, -7) {$C$};
        \node[noeud] (D) at (6, -4) {$D$};
        \node[noeud] (E) at (8, -7) {$E$};
        \node[noeud] (F) at (10, -4) {$F$};
        \node[noeud] (G) at (12, -7) {$G$};

        \draw[-] (A) to (B);
        \draw[-] (A) to (C);
        \draw[-] (A) to (D);

        \draw[-] (B) to (C);
        
        \draw[-] (C) to (D);
        \draw[-] (C) to (E);
        \draw[-] (C) to (F);

        \draw[-] (D) to (E);
        \draw[-] (D) to (F);

        \draw[-] (F) to (G);
    \end{tikzpicture}
    \caption{Un exemple de graphe d'intervalles}
    \label{fig:ex_gint}
\end{figure}

Pour le problème \bisched, le rapport avec les graphe d'intervalles ne s'arrête pas là, en effet, le
problème a été démontré équivalent à la recherche du nombre chromatique du graphe d'intervalle
associé au problème~\cite{golumbicalgorithmic}. Le nombre chromatique d'un graphe étant le plus
petit nombre de couleurs nécessaires à la coloration d'un graphe. Dans la mesure où le problème de
coloration de graphes d'intervalles est polynomiale, le problème \bisched l'est aussi, ainsi Ford et
Fulkerson ont proposé en 1962, un algorithme s'exécutant en $O(n^2)$
opérations~\cite{ford1962network}. Depuis d'autres méthodes ont été proposées notamment par Gupta et
al. ayant une complexité en $O(n\log n)$ opérations et qu'ils ont démontrée comme atteignant la
meilleur complexité possible~\cite{gupta_optimal_1978}.

L'algorithme repose sur une observation simple : le nombre minimal de couleur nécessaire à la
coloration du graphe d'intervalle est égal à la taille de la plus grande clique de ce graphe, or une
clique de taille $k$ dans le graphe associé à l'ensemble des tâches correspond à une durée pendant
laquelle $k$ intervalles s'intersectent deux à deux. Ainsi, en parcourant les dates de début des tâches par
ordre de dates de début, et en assignant cette tâche à une machine, ayant déjà été utilisée
précédemment, l'algorithme s'assure qu'une nouvelle machine est utilisée lorsque le nombre de
tâches s'intersectant deux à deux est supérieur aux nombres de machines déjà utilisées. Dans ce cas
le nombre de couleur déjà utilisé pour colorer le graphe est inférieur à la taille de la clique
courante (et donc nécessairement de la plus grande clique).

Un algorithme distribué a été mis au point par Dekel et Sani~\cite{dekel1983parallel}, permettant la
résolution de ce problème en $O(\log n)$ moyennant $O(n^2 / \log n)$ machines.

\subsection{Quelques variantes de ce problème}

Il existe beaucoup de déclinaisons du problème \bisched considérant une autre fonction objectif,
modifiant l'environnement des processeurs, ou encore introduisant de nouvelles notions permettant
d'augmenter l'expressivité du modèle. Parmi ces variantes, nous en avons choisi deux permettant de
définir le contexte de notre modèle.

\subsubsection{Nombre de machines fixé}

Cette variante, contrairement au problème originel, fixe le nombre de machines pouvant exécuter les
tâches et cherche un ordonnancement permettant de maximiser la somme du poids des tâches affectées à
une machine. Le poids $w_j$ d'une tâche $j$ peut être vu comme le profit généré par l'exécution de
la tâche $j$, le problème cherche alors à maximiser les gains.

Nous noterons ce problème :
\begin{center}
    $P \Big| . . inter \Big| \max \sum w_j : j$ est affectée à une machine de $\mathcal{M}$
\end{center}

Sans contraintes supplémentaires, le problème est polynomial, Arkin et Silverberg ayant proposé en
1986 un algorithme s'exécutant en $O(n^2 \log n)$ opérations~\cite{arkin_scheduling_1987}. Cet
algorithme repose sur la même observation que celui de Gupta et al. précédemment présenté : il faut
exactement $p$ couleurs pour colorer une clique de taille $p$. Donc étant donné $\mathcal{M}=\left\{
m_1, m_2, \dots, m_k \right\}$ un ensemble de $k$ machines, pour toutes les cliques de taille
$p$ supérieure à $k$, l'algorithme cherche à supprimer les $p -k$ sommets de la clique présentant
le plus petit profit. Ces sommets sont identifiés à l'aide d'un algorithme de flot de coût minimum
dans un graphe construit à partir des cliques du graphes d'intervalles de départ.

Cet algorithme a donc la particularité de trouver un ordonnancement de profit maximal, non pas en
trouvant les tâches à affecter, mais en trouvant celle à ne pas affecter.

À présent, considérons ce même problème, à ceci prêt : chaque tâche $j$ de $\mathcal{T}$ va se voir
attribuer un ensemble de machines $\mathcal{M}_j \subseteq \mathcal{M}$ représentant l'ensemble des
machines sur lesquelles la tâche $j$ peut être exécutée.

Ce problème devient alors \npc si le nombre de machine dans chaque sous-ensemble $\mathcal{M_j}$ est
supérieur ou égal à $3$~\cite{arkin_scheduling_1987}, la preuve se faisant par une réduction depuis
le problème \textsc{$3-$SAT}. Un algorithme exprimé sous forme de programmation dynamique a été
décrit dans ce même article, il s'exécute en $O(n^{k+1})$.

Bhatia et al. ont proposé une $(1 - 1/\varepsilon)-$approximation
randomisée~\cite{bhatia2003algorithmic} basée sur de la programmation linéaire permettant la
résolution de ce problème. De plus de nombreuses heuristiques ont été introduite pour répondre à ce
problème, nous renvoyons les intéressés à la lectures des articles~\cite{kroon1995exact}
et~\cite{gabrel1995scheduling}.

\subsubsection{Indisponibilité de machines}

Une seconde extension au problème \bisched est une variante introduisant des périodes au cours
desquelles certaines machines seront dites indisponibles et donc pendant lesquelles elles ne
pourront effectuer aucun calcul. La machine entrant en indisponibilité ne doit avoir aucune tâche en
court d'exécution, un ordonnancement présentant une intersection entre une tâche et une
indisponibilité n'est donc pas un ordonnancement valide.

Comme vu précédemment, les problèmes d'ordonnancement d'intervalles ont un lien fort avec les
graphes d'intervalles, \bisched étant équivalent au problème de coloration sur ces derniers. Il
existe une catégorie de graphe, à savoir les graphes à arcs circulaires qui est le
graphe d'intersection d'un ensemble d'arcs de cercle, dont le problème de coloration est équivalent
au problème avec machines indisponibles. Un exemple de graphe est donné à la figure~\ref{fig:ex_ac}.

Non seulement le problème \isma a été démontré \npc par
Papadimitriou~\cite{papadimitriou1982private} à l'aide d'une réduction depuis le problème de
coloration sur un graphe à arcs circulaires, mais il a plus tard été démontré polynomialement
équivalent à ce problème par Kolen et al.~\cite{kolen2007interval}. Ces mêmes auteurs ont également
proposé deux algorithmes exact pour la résolution de ce problème, le premier utilise la
programmation dynamique s'exécutant en $O(ln^{l+1})$, avec $l$ la taille de la plus grand clique dans
le graphe à arcs circulaires. Le second algorithme, quant à lui, réalise une énumération  basée sur
la notion d'ordonnancement partiel : un ordonnancement partiel jusqu'à la date $t$ est une
assignation à une machine de chacune des tâches dont la date de début est antérieure à $t$ de sorte
que deux tâches de s'exécutent en même temps sur la même machine. Cette algorithme s'exécute en
$O\left( n+k \right)k!k \log k)$ opérations, avec $k$ le nombre de machines. Cet algorithme est
particulièrement intéressant puisque si le nombre de machines pour \isma est fixé, alors l'algorithme
devient linéaire en le nombre de tâches.

\begin{figure}
    \centering
    \begin{tikzpicture}[n/.style={draw=black, circle}, scale=0.7, every node/.style={transform shape}, >=latex]
        \node[n] (A) at (1, 4) {$A$};
        \node[n] (B) at (3, 4) {$B$};
        \node[n] (C) at (4, 2) {$C$};
        \node[n] (D) at (2, 0) {$D$};
        \node[n] (E) at (0, 2) {$E$};

        \draw[-] (A) to (B);
        \draw[-] (A) to (E);

        \draw[-] (B) to (C);

        \draw[-] (C) to (D);
        \draw[-] (C) to (E);

        \draw[-] (D) to (E);

        \draw (10,2) circle (1.5cm);
        \draw[rotate around={100:(10,2)}, <->] (12, 2) arc (0:60:2cm);
        \draw[rotate around={150:(10,2)}, <->] (12.5, 2) arc (0:40:2.5cm);
        \draw[rotate around={180:(10,2)}, <->] (12, 2) arc (0:90:2cm);
        \draw[rotate around={180:(10,2)}, <->] (13, 2) arc (0:240:3cm);
        \draw[rotate around={ 50:(10,2)}, <->] (12.5, 2) arc (0:60:2.5cm);

        \node (a) at (8.3, 3.7) {$A$}; 
        \node (b) at (10.4, 4.9) {$B$}; 
        \node (c) at (12.2, -0.7) {$C$}; 
        \node (d) at (8.5, 0) {$D$}; 
        \node (e) at (7.2, 2.4) {$E$}; 
        
    \end{tikzpicture}
    \caption{Exemple de graphe à arcs circulaires}
    \label{fig:ex_ac}
\end{figure}

Il existe différentes façons de représenter l'indisponibilité d'une machine pendant une période
donnée. Supposons que nous ayons une machine $m$ indisponible pendant le laps de temps représenté par
l'intervalle $i_m = \left[ \sint{i_m}, \cint{i_m} \right]$, une première façon d'envisager un tel
scénario est de considérer deux machines $m_1, m_2$ telles que la machine $m_1$ est disponible
pendant la durée $\left[ 0, \sin{i_m} \right]$ et la machine $m_2$ est disponible entre les dates
$\left[ \cint{i_m}, \infty \right]$. Une seconde façon de voir ce scénario est de considérer que
l'indisponibilité de la machine n'est autre qu'une tâche pré affectée à la machine indisponible. C'est
cette représentation que nous allons utiliser pour l'introduction du problème \fisched qui sera
étudié tout au long de ce stage.

\subsubsection{Flexibilité de l'ordonnancement}

Nous introduisons par la même occasion la notion de flexibilité d'un ordonnancement, c'est à dire,
sa capacité à pouvoir accepter un plus grand nombre de tâches ultérieurement. L'origine de cette
problématique est due à l'accroissement de services proposés par les grandes compagnies numériques
sur la toile. Il est en effet possible, de louer les ressources de calcul générées par une machine
pendant une durée définie par l'utilisateur. La question visant à maximiser le profit ayant été
largement étudiée, nous nous intéressons à la manière d'ordonnancer les tâches à disposition afin de
pouvoir garantir l'acceptation de toute tâche répondant à une contrainte. 

Pour mesurer la flexibilité de l'ordonnancement nous avons fait le choix d'introduire la notion de
trou : un période d'inactivité non nulle d'une machine délimitée à gauche et à droite par des tâches
ordonnancées sur la dite machine. Il paraît en effet évident qu'un trou de grande longueur sera
susceptible d'accueillir un plus grand nombre de tâches futures qu'une multitude de petit trous.
La fonction objectif considérée cherchera donc à maximiser le plus petit des trous de
l'ordonnancement produit.

Enfin, nous plaçons dans un contexte tel que les machines ne sont pas continûment disponible : comme
introduit précédemment, nous considérons un ensemble de tâches pré affectées à un ensemble de
machines, représentant les tâches ayant été précédemment ordonnancée. Ces périodes d'inactivités
seront appelées réservations, et dorénavant, les trous considérés pourront être délimités à gauche
et à droite par des tâches et/ou des réservations.

Si l'on considère :
\begin{itemize}
    \item $\mathcal{T} = \left\{ j_1, j_2, \dots, j_n \right\}$, l'ensemble des tâches à ordonnancer
        associé à un ensemble d'intervalles $\mathcal{I} = \left\{ i_{j_1}, i_{j_2}, \dots,
        i_{j_n} \right\}$,
    \item $\mathcal{M} = \left\{ m_1, m_2, \dots, m_k \right\}$ l'ensemble des machines 
    \item $\mathcal{R} = \left\{ l_1, l_2, \dots, l_h \right\}$ l'ensemble des réservations
        représentable par un couple $\left( m_l, \left[ \sres{l}, \cres{l} \right] \right)$
        comprenant la machine à laquelle est pré affectée la réservation $l$ et l'intervalle
        représentant la période d'indisponibilité de la machine $m_l$
    \item $H_{\min} = \min \left\{ \sint{i'} - \cint{i} > 0 : i, i' \in \mathcal{T} \cup
        \mathcal{R} \right\}$ la fonction permettant de calculer la valeur du trou minimum,
\end{itemize}
alors la notation à trois champs de notre problème est la suivante :
\begin{center}
    $P \Big| .. inter \Big| \max H_{\min}$
\end{center}

\newpage

\section{Ligne de conduite}

Le stage portant sur le problème précédemment introduit sera abordé de la manière suivante :
\begin{enumerate}
    \item Dans un premier temps, nous nous intéresserons à la classification du problème du point de
        vue de la complexité. À savoir répondre aux questions suivantes :
        \begin{itemize}
            \item \fisched est il \npc?
            \item est il FPT?
        \end{itemize}
    \item Puis nous chercherons à mettre au points différents algorithmes exacts ou
        d'approximation\footnote{Uniquement si le problème est \npc.}, en nous intéressant d'abord à
        la possible existence d'un algorithme basé sur la programmation dynamique, puis à une
        formulation en programmation linéaire.
    \item Enfin nous envisagerons différentes variantes du problème telles qu'une variante online,
        c'est à dire que l'ensemble des tâches à ordonnancer est initialement connue en partie
        seulement, et que les autres tâches sont dévoilées au fur et à mesure du temps, qui paraît
        s'inscrire naturellement dans le sillage de notre problème.
\end{enumerate}

Il sera aussi intéressant de continuer à parcourir la littérature dans le but d'établir des
relations de hiérarchie voir d'équivalence avec des problèmes déjà étudiés.


\newpage
\appendix
\bibliographystyle{plain}
\bibliography{biblio}


\end{document}
