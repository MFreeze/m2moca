/*
**************************************************************************
**       Advanced Encryption Standard - 128 - implementation in C.      **
**      Chiffrement et dechiffrement                                    **
**************************************************************************


C'est un code source pour le chiffrement et le dechiffrement AES-128
is the source code for encryption using the latest AES algorithm.


******************************************************************
*/


#include<stdio.h>
#include<stdlib.h>
#include<time.h>


#define SUM4(s) (((s) &  1) ^ (((s) & 2) >> 1)  ^ (((s) & 4) >> 2)  ^ (((s) & 8) >> 3))


// Macro de multiplication par x 	
#define xtime(x)   ((((x)<<1) ^ ((((x)>>7) & 1) * 27)) & 255)
#define Nk 4

typedef unsigned int UINT;


// Les blocks de  messages sont stockes sur un tableau de 16 uchar
// M=[ M_0 .. M_3 | M_4 .. M_7 | M_8 .. M_11 | M_12 .. M_15 ] 
// M=[ colone 0   | colone 1   | colone 2    | colone 3     ]

// Le tableau de la fonction de substitution
int sbox[256] =   {
	//0     1    2      3     4    5     6     7      8    9     A      B    C     D     E     F
	0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, //0
	0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, //1
	0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, //2
	0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, //3
	0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, //4
	0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, //5
	0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, //6
	0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, //7
	0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, //8
	0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, //9
	0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, //A
	0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, //B
	0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, //C
	0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, //D
	0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, //E
	0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 }; //F

int sboxinv[256] = 
 {0x52 ,0x09 ,0x6a ,0xd5 ,0x30 ,0x36 ,0xa5 ,0x38 ,0xbf ,0x40 ,0xa3 ,0x9e ,0x81 ,0xf3 ,0xd7 ,0xfb
 ,0x7c ,0xe3 ,0x39 ,0x82 ,0x9b ,0x2f ,0xff ,0x87 ,0x34 ,0x8e ,0x43 ,0x44 ,0xc4 ,0xde ,0xe9 ,0xcb
 ,0x54 ,0x7b ,0x94 ,0x32 ,0xa6 ,0xc2 ,0x23 ,0x3d ,0xee ,0x4c ,0x95 ,0x0b ,0x42 ,0xfa ,0xc3 ,0x4e
 ,0x08 ,0x2e ,0xa1 ,0x66 ,0x28 ,0xd9 ,0x24 ,0xb2 ,0x76 ,0x5b ,0xa2 ,0x49 ,0x6d ,0x8b ,0xd1 ,0x25
 ,0x72 ,0xf8 ,0xf6 ,0x64 ,0x86 ,0x68 ,0x98 ,0x16 ,0xd4 ,0xa4 ,0x5c ,0xcc ,0x5d ,0x65 ,0xb6 ,0x92
 ,0x6c ,0x70 ,0x48 ,0x50 ,0xfd ,0xed ,0xb9 ,0xda ,0x5e ,0x15 ,0x46 ,0x57 ,0xa7 ,0x8d ,0x9d ,0x84
 ,0x90 ,0xd8 ,0xab ,0x00 ,0x8c ,0xbc ,0xd3 ,0x0a ,0xf7 ,0xe4 ,0x58 ,0x05 ,0xb8 ,0xb3 ,0x45 ,0x06
 ,0xd0 ,0x2c ,0x1e ,0x8f ,0xca ,0x3f ,0x0f ,0x02 ,0xc1 ,0xaf ,0xbd ,0x03 ,0x01 ,0x13 ,0x8a ,0x6b
 ,0x3a ,0x91 ,0x11 ,0x41 ,0x4f ,0x67 ,0xdc ,0xea ,0x97 ,0xf2 ,0xcf ,0xce ,0xf0 ,0xb4 ,0xe6 ,0x73
 ,0x96 ,0xac ,0x74 ,0x22 ,0xe7 ,0xad ,0x35 ,0x85 ,0xe2 ,0xf9 ,0x37 ,0xe8 ,0x1c ,0x75 ,0xdf ,0x6e
 ,0x47 ,0xf1 ,0x1a ,0x71 ,0x1d ,0x29 ,0xc5 ,0x89 ,0x6f ,0xb7 ,0x62 ,0x0e ,0xaa ,0x18 ,0xbe ,0x1b
 ,0xfc ,0x56 ,0x3e ,0x4b ,0xc6 ,0xd2 ,0x79 ,0x20 ,0x9a ,0xdb ,0xc0 ,0xfe ,0x78 ,0xcd ,0x5a ,0xf4
 ,0x1f ,0xdd ,0xa8 ,0x33 ,0x88 ,0x07 ,0xc7 ,0x31 ,0xb1 ,0x12 ,0x10 ,0x59 ,0x27 ,0x80 ,0xec ,0x5f
 ,0x60 ,0x51 ,0x7f ,0xa9 ,0x19 ,0xb5 ,0x4a ,0x0d ,0x2d ,0xe5 ,0x7a ,0x9f ,0x93 ,0xc9 ,0x9c ,0xef
 ,0xa0 ,0xe0 ,0x3b ,0x4d ,0xae ,0x2a ,0xf5 ,0xb0 ,0xc8 ,0xeb ,0xbb ,0x3c ,0x83 ,0x53 ,0x99 ,0x61
 ,0x17 ,0x2b ,0x04 ,0x7e ,0xba ,0x77 ,0xd6 ,0x26 ,0xe1 ,0x69 ,0x14 ,0x63 ,0x55 ,0x21 ,0x0c ,0x7d};



// The round constant word array, Rcon[i], contains the values given by 
// x to th e power (i-1) being powers of x (x is denoted as {02}) in the field GF(28)
// Note that i starts at 1, not 0).
int Rcon[255] = {
	0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 
	0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 
	0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 
	0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 
	0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 
	0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 
	0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 
	0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 
	0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 
	0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 
	0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 
	0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 
	0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 
	0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 
	0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 
	0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb  };

// Table de multiplication par les constantes E,B,D et 9 nécéssaire dans InvMixColumns 

int MulE[256] = {
  0x0, 0xe, 0x1c, 0x12, 0x38, 0x36, 0x24, 0x2a, 0x70, 0x7e, 0x6c, 0x62, 0x48, 0x46, 0x54, 0x5a, 0xe0, 0xee, 0xfc, 0xf2, 0xd8, 0xd6, 0xc4, 0xca, 0x90, 0x9e, 0x8c, 0x82, 0xa8, 0xa6, 0xb4, 0xba, 0xdb, 0xd5, 0xc7, 0xc9, 0xe3, 0xed, 0xff, 0xf1, 0xab, 0xa5, 0xb7, 0xb9, 0x93, 0x9d, 0x8f, 0x81, 0x3b, 0x35, 0x27, 0x29, 0x3, 0xd, 0x1f, 0x11, 0x4b, 0x45, 0x57, 0x59, 0x73, 0x7d, 0x6f, 0x61, 0xad, 0xa3, 0xb1, 0xbf, 0x95, 0x9b, 0x89, 0x87, 0xdd, 0xd3, 0xc1, 0xcf, 0xe5, 0xeb, 0xf9, 0xf7, 0x4d, 0x43, 0x51, 0x5f, 0x75, 0x7b, 0x69, 0x67, 0x3d, 0x33, 0x21, 0x2f, 0x5, 0xb, 0x19, 0x17, 0x76, 0x78, 0x6a, 0x64, 0x4e, 0x40, 0x52, 0x5c, 0x6, 0x8, 0x1a, 0x14, 0x3e, 0x30, 0x22, 0x2c, 0x96, 0x98, 0x8a, 0x84, 0xae, 0xa0, 0xb2, 0xbc, 0xe6, 0xe8, 0xfa, 0xf4, 0xde, 0xd0, 0xc2, 0xcc, 0x41, 0x4f, 0x5d, 0x53, 0x79, 0x77, 0x65, 0x6b, 0x31, 0x3f, 0x2d, 0x23, 0x9, 0x7, 0x15, 0x1b, 0xa1, 0xaf, 0xbd, 0xb3, 0x99, 0x97, 0x85, 0x8b, 0xd1, 0xdf, 0xcd, 0xc3, 0xe9, 0xe7, 0xf5, 0xfb, 0x9a, 0x94, 0x86, 0x88, 0xa2, 0xac, 0xbe, 0xb0, 0xea, 0xe4, 0xf6, 0xf8, 0xd2, 0xdc, 0xce, 0xc0, 0x7a, 0x74, 0x66, 0x68, 0x42, 0x4c, 0x5e, 0x50, 0xa, 0x4, 0x16, 0x18, 0x32, 0x3c, 0x2e, 0x20, 0xec, 0xe2, 0xf0, 0xfe, 0xd4, 0xda, 0xc8, 0xc6, 0x9c, 0x92, 0x80, 0x8e, 0xa4, 0xaa, 0xb8, 0xb6, 0xc, 0x2, 0x10, 0x1e, 0x34, 0x3a, 0x28, 0x26, 0x7c, 0x72, 0x60, 0x6e, 0x44, 0x4a, 0x58, 0x56, 0x37, 0x39, 0x2b, 0x25, 0xf, 0x1, 0x13, 0x1d, 0x47, 0x49, 0x5b, 0x55, 0x7f, 0x71, 0x63, 0x6d, 0xd7, 0xd9, 0xcb, 0xc5, 0xef, 0xe1, 0xf3, 0xfd, 0xa7, 0xa9, 0xbb, 0xb5, 0x9f, 0x91, 0x83, 0x8d };



int MulB[256] = {
0x0, 0xb, 0x16, 0x1d, 0x2c, 0x27, 0x3a, 0x31, 0x58, 0x53, 0x4e, 0x45, 0x74, 0x7f, 0x62, 0x69, 0xb0, 0xbb, 0xa6, 0xad, 0x9c, 0x97, 0x8a, 0x81, 0xe8, 0xe3, 0xfe, 0xf5, 0xc4, 0xcf, 0xd2, 0xd9, 0x7b, 0x70, 0x6d, 0x66, 0x57, 0x5c, 0x41, 0x4a, 0x23, 0x28, 0x35, 0x3e, 0xf, 0x4, 0x19, 0x12, 0xcb, 0xc0, 0xdd, 0xd6, 0xe7, 0xec, 0xf1, 0xfa, 0x93, 0x98, 0x85, 0x8e, 0xbf, 0xb4, 0xa9, 0xa2, 0xf6, 0xfd, 0xe0, 0xeb, 0xda, 0xd1, 0xcc, 0xc7, 0xae, 0xa5, 0xb8, 0xb3, 0x82, 0x89, 0x94, 0x9f, 0x46, 0x4d, 0x50, 0x5b, 0x6a, 0x61, 0x7c, 0x77, 0x1e, 0x15, 0x8, 0x3, 0x32, 0x39, 0x24, 0x2f, 0x8d, 0x86, 0x9b, 0x90, 0xa1, 0xaa, 0xb7, 0xbc, 0xd5, 0xde, 0xc3, 0xc8, 0xf9, 0xf2, 0xef, 0xe4, 0x3d, 0x36, 0x2b, 0x20, 0x11, 0x1a, 0x7, 0xc, 0x65, 0x6e, 0x73, 0x78, 0x49, 0x42, 0x5f, 0x54, 0xf7, 0xfc, 0xe1, 0xea, 0xdb, 0xd0, 0xcd, 0xc6, 0xaf, 0xa4, 0xb9, 0xb2, 0x83, 0x88, 0x95, 0x9e, 0x47, 0x4c, 0x51, 0x5a, 0x6b, 0x60, 0x7d, 0x76, 0x1f, 0x14, 0x9, 0x2, 0x33, 0x38, 0x25, 0x2e, 0x8c, 0x87, 0x9a, 0x91, 0xa0, 0xab, 0xb6, 0xbd, 0xd4, 0xdf, 0xc2, 0xc9, 0xf8, 0xf3, 0xee, 0xe5, 0x3c, 0x37, 0x2a, 0x21, 0x10, 0x1b, 0x6, 0xd, 0x64, 0x6f, 0x72, 0x79, 0x48, 0x43, 0x5e, 0x55, 0x1, 0xa, 0x17, 0x1c, 0x2d, 0x26, 0x3b, 0x30, 0x59, 0x52, 0x4f, 0x44, 0x75, 0x7e, 0x63, 0x68, 0xb1, 0xba, 0xa7, 0xac, 0x9d, 0x96, 0x8b, 0x80, 0xe9, 0xe2, 0xff, 0xf4, 0xc5, 0xce, 0xd3, 0xd8, 0x7a, 0x71, 0x6c, 0x67, 0x56, 0x5d, 0x40, 0x4b, 0x22, 0x29, 0x34, 0x3f, 0xe, 0x5, 0x18, 0x13, 0xca, 0xc1, 0xdc, 0xd7, 0xe6, 0xed, 0xf0, 0xfb, 0x92, 0x99, 0x84, 0x8f, 0xbe, 0xb5, 0xa8, 0xa3 };



int MulD[256] = {
0x0, 0xd, 0x1a, 0x17, 0x34, 0x39, 0x2e, 0x23, 0x68, 0x65, 0x72, 0x7f, 0x5c, 0x51, 0x46, 0x4b, 0xd0, 0xdd, 0xca, 0xc7, 0xe4, 0xe9, 0xfe, 0xf3, 0xb8, 0xb5, 0xa2, 0xaf, 0x8c, 0x81, 0x96, 0x9b, 0xbb, 0xb6, 0xa1, 0xac, 0x8f, 0x82, 0x95, 0x98, 0xd3, 0xde, 0xc9, 0xc4, 0xe7, 0xea, 0xfd, 0xf0, 0x6b, 0x66, 0x71, 0x7c, 0x5f, 0x52, 0x45, 0x48, 0x3, 0xe, 0x19, 0x14, 0x37, 0x3a, 0x2d, 0x20, 0x6d, 0x60, 0x77, 0x7a, 0x59, 0x54, 0x43, 0x4e, 0x5, 0x8, 0x1f, 0x12, 0x31, 0x3c, 0x2b, 0x26, 0xbd, 0xb0, 0xa7, 0xaa, 0x89, 0x84, 0x93, 0x9e, 0xd5, 0xd8, 0xcf, 0xc2, 0xe1, 0xec, 0xfb, 0xf6, 0xd6, 0xdb, 0xcc, 0xc1, 0xe2, 0xef, 0xf8, 0xf5, 0xbe, 0xb3, 0xa4, 0xa9, 0x8a, 0x87, 0x90, 0x9d, 0x6, 0xb, 0x1c, 0x11, 0x32, 0x3f, 0x28, 0x25, 0x6e, 0x63, 0x74, 0x79, 0x5a, 0x57, 0x40, 0x4d, 0xda, 0xd7, 0xc0, 0xcd, 0xee, 0xe3, 0xf4, 0xf9, 0xb2, 0xbf, 0xa8, 0xa5, 0x86, 0x8b, 0x9c, 0x91, 0xa, 0x7, 0x10, 0x1d, 0x3e, 0x33, 0x24, 0x29, 0x62, 0x6f, 0x78, 0x75, 0x56, 0x5b, 0x4c, 0x41, 0x61, 0x6c, 0x7b, 0x76, 0x55, 0x58, 0x4f, 0x42, 0x9, 0x4, 0x13, 0x1e, 0x3d, 0x30, 0x27, 0x2a, 0xb1, 0xbc, 0xab, 0xa6, 0x85, 0x88, 0x9f, 0x92, 0xd9, 0xd4, 0xc3, 0xce, 0xed, 0xe0, 0xf7, 0xfa, 0xb7, 0xba, 0xad, 0xa0, 0x83, 0x8e, 0x99, 0x94, 0xdf, 0xd2, 0xc5, 0xc8, 0xeb, 0xe6, 0xf1, 0xfc, 0x67, 0x6a, 0x7d, 0x70, 0x53, 0x5e, 0x49, 0x44, 0xf, 0x2, 0x15, 0x18, 0x3b, 0x36, 0x21, 0x2c, 0xc, 0x1, 0x16, 0x1b, 0x38, 0x35, 0x22, 0x2f, 0x64, 0x69, 0x7e, 0x73, 0x50, 0x5d, 0x4a, 0x47, 0xdc, 0xd1, 0xc6, 0xcb, 0xe8, 0xe5, 0xf2, 0xff, 0xb4, 0xb9, 0xae, 0xa3, 0x80, 0x8d, 0x9a, 0x97 };

int Mul9[256] = {
0x0, 0x9, 0x12, 0x1b, 0x24, 0x2d, 0x36, 0x3f, 0x48, 0x41, 0x5a, 0x53, 0x6c, 0x65, 0x7e, 0x77, 0x90, 0x99, 0x82, 0x8b, 0xb4, 0xbd, 0xa6, 0xaf, 0xd8, 0xd1, 0xca, 0xc3, 0xfc, 0xf5, 0xee, 0xe7, 0x3b, 0x32, 0x29, 0x20, 0x1f, 0x16, 0xd, 0x4, 0x73, 0x7a, 0x61, 0x68, 0x57, 0x5e, 0x45, 0x4c, 0xab, 0xa2, 0xb9, 0xb0, 0x8f, 0x86, 0x9d, 0x94, 0xe3, 0xea, 0xf1, 0xf8, 0xc7, 0xce, 0xd5, 0xdc, 0x76, 0x7f, 0x64, 0x6d, 0x52, 0x5b, 0x40, 0x49, 0x3e, 0x37, 0x2c, 0x25, 0x1a, 0x13, 0x8, 0x1, 0xe6, 0xef, 0xf4, 0xfd, 0xc2, 0xcb, 0xd0, 0xd9, 0xae, 0xa7, 0xbc, 0xb5, 0x8a, 0x83, 0x98, 0x91, 0x4d, 0x44, 0x5f, 0x56, 0x69, 0x60, 0x7b, 0x72, 0x5, 0xc, 0x17, 0x1e, 0x21, 0x28, 0x33, 0x3a, 0xdd, 0xd4, 0xcf, 0xc6, 0xf9, 0xf0, 0xeb, 0xe2, 0x95, 0x9c, 0x87, 0x8e, 0xb1, 0xb8, 0xa3, 0xaa, 0xec, 0xe5, 0xfe, 0xf7, 0xc8, 0xc1, 0xda, 0xd3, 0xa4, 0xad, 0xb6, 0xbf, 0x80, 0x89, 0x92, 0x9b, 0x7c, 0x75, 0x6e, 0x67, 0x58, 0x51, 0x4a, 0x43, 0x34, 0x3d, 0x26, 0x2f, 0x10, 0x19, 0x2, 0xb, 0xd7, 0xde, 0xc5, 0xcc, 0xf3, 0xfa, 0xe1, 0xe8, 0x9f, 0x96, 0x8d, 0x84, 0xbb, 0xb2, 0xa9, 0xa0, 0x47, 0x4e, 0x55, 0x5c, 0x63, 0x6a, 0x71, 0x78, 0xf, 0x6, 0x1d, 0x14, 0x2b, 0x22, 0x39, 0x30, 0x9a, 0x93, 0x88, 0x81, 0xbe, 0xb7, 0xac, 0xa5, 0xd2, 0xdb, 0xc0, 0xc9, 0xf6, 0xff, 0xe4, 0xed, 0xa, 0x3, 0x18, 0x11, 0x2e, 0x27, 0x3c, 0x35, 0x42, 0x4b, 0x50, 0x59, 0x66, 0x6f, 0x74, 0x7d, 0xa1, 0xa8, 0xb3, 0xba, 0x85, 0x8c, 0x97, 0x9e, 0xe9, 0xe0, 0xfb, 0xf2, 0xcd, 0xc4, 0xdf, 0xd6, 0x31, 0x38, 0x23, 0x2a, 0x15, 0x1c, 0x7, 0xe, 0x79, 0x70, 0x6b, 0x62, 0x5d, 0x54, 0x4f, 0x46 };



// La fonction affichage_tableau4par4 affiche un bloc de message 
void affichage_tableau4par4(unsigned char *in)
{
  int i,j,k;
  for(i=0;i<4;i++)
    {
      for(j=0;j<4;j++)
 	{
	  printf("%02x ",in[4*j+i]);
	  
	}
      printf("\n");
    }
  printf("\n");

}

// La fonction affichage_binaire affiche un bloc de message 
void affichage_binaire(unsigned char *in)
{
  int i,j,k;

  for(i=0;i<4;i++)
    {
      for(j=0;j<4;j++)
 	{
	  printf("%u%u%u%u",(in[4*j+i] >>7) & 1,(in[4*j+i] >>6)& 1,(in[4*j+i] >>5)& 1,(in[4*j+i] >> 4) & 1);
	  printf("%u%u%u%u  ",(in[4*j+i] >>3) & 1,(in[4*j+i] >>2)& 1,(in[4*j+i] >>1)& 1,in[4*j+i] & 1);

	}
      printf("\n");
    }
printf("\n");

}

// La fonction Add fait un XOR bit a bit avec deux block de 16 octets
void Add(unsigned char out[], unsigned char in1[],unsigned char in2[])
{
	int i,j;
	for(i=0;i<16;i++)
	{
	  out[i] =in1[i] ^in2[i];		
	}
}


// La fonction Affecte la valeur des octets de tableau  in dans le tableau out
void Affecte(unsigned char out[], unsigned char in[])
{
  int i,j;
  for(i=0;i<16;i++)
    {
      out[i] =in[i];		
    }
}


// La fonction KeyExpansion produit les 4(Nr+1) clef de roundes, ou Nr est le nombre de clef de rondes
void KeyExpansion( unsigned char *RoundKey, unsigned char Key[], int Nr)
{
  int i,j;
  unsigned char temp[4],k;
	
  // The first round key is the key itself.
  for(j=0;j<Nk;j++)
    {
      RoundKey[j*4]=Key[j*4];
      RoundKey[j*4+1]=Key[j*4+1];
      RoundKey[j*4+2]=Key[j*4+2];
      RoundKey[j*4+3]=Key[j*4+3];
    }

  // All other round keys are found from the previous round keys.
  while (j < (4 * (Nr+1)))
    {
      for(i=0;i<4;i++)
	{
	  temp[i]=RoundKey[(j-1) * 4 + i];
	}
      if (j % Nk == 0)
	{
	  // This function rotates the 4 bytes in a word to the left once.
	  // [a0,a1,a2,a3] becomes [a1,a2,a3,a0]

	  // Function RotWord()
	  {
	    k = temp[0];
	    temp[0] = temp[1];
	    temp[1] = temp[2];
	    temp[2] = temp[3];
	    temp[3] = k;
	  }

	  // SubWord() is a function that takes a four-byte input word and 
	  // applies the S-box to each of the four bytes to produce an output word.

	  // Function Subword()
	  {
	    temp[0]=sbox[temp[0]];
	    temp[1]=sbox[temp[1]];
	    temp[2]=sbox[temp[2]];
	    temp[3]=sbox[temp[3]];
	  }

	  temp[0] =  temp[0] ^ Rcon[j/Nk];
	}
      else if ((Nk > 6) && ((j % Nk) == 4))
	{
	  // Function Subword()
	  {
	    temp[0]=sbox[temp[0]];
	    temp[1]=sbox[temp[1]];
	    temp[2]=sbox[temp[2]];
	    temp[3]=sbox[temp[3]];
	  }
	}
      RoundKey[j*4+0] = RoundKey[(j-Nk)*4+0] ^ temp[0];
      RoundKey[j*4+1] = RoundKey[(j-Nk)*4+1] ^ temp[1];
      RoundKey[j*4+2] = RoundKey[(j-Nk)*4+2] ^ temp[2];
      RoundKey[j*4+3] = RoundKey[(j-Nk)*4+3] ^ temp[3];
      j++;
    }
}

// La fonction AddRoundKey ajoute la clef de ronde
void AddRoundKey(unsigned char *out, unsigned char *in,unsigned char RoundKey[], int round) 
{
	int i,j;
	for(i=0;i<4;i++)
	{
		for(j=0;j<4;j++)
		{
			out[4*j+i] =in[4*j+i]^ RoundKey[round * 16 + j * 4 + i];
		}
	}
}

// La fonction  SubBytes substitue les valeurs des 16 octets du bloc de message
void SubBytes(unsigned char *out, unsigned char *in)
{
	int i,j;
	for(i=0;i<4;i++)
	{
		for(j=0;j<4;j++)
		{
		  out[4*j+i] = (unsigned char) sbox[in[4*j+i]];

		}
	}
}

// La fonction  SubBytes substitue les valeurs des 16 octets du bloc de message
void InvSubBytes(unsigned char *out, unsigned char *in)
{
	int i,j;
	for(i=0;i<4;i++)
	{
		for(j=0;j<4;j++)
		{
		  out[4*j+i] = (unsigned char) sboxinv[in[4*j+i]];

		}
	}
}



//  La fonction ShiftRows() decale cycliquement les lignes du bloc message
// de 0,1,2,3 sur la la gauche pour les 1er, 2eme, 3eme, 4eme ligne respectivement
void ShiftRows(unsigned char *out, unsigned char *in)
{
	int j;
	// la premiere ligne est inchangee
	for(j=0;j<4;j++)
	  {
	    out[4*j]=in[4*j];
	  }
	// dexieme ligne on decalage de 1 sur la gauche 
	for(j=0;j<3;j++)
	  {
	    out[4*j+1]=in[4*(j+1)+1];
	  }
	out[4*3+1]=in[1];
	// deuxieme ligne on decalage de 1 sur la gauche 
	for(j=0;j<2;j++)
	  {
	    out[4*j+2]=in[4*(j+2)+2];
	    out[4*(j+2)+2]=in[4*(j)+2];
	  }
	out[4*3+1]=in[1];
	// quatrieme ligne on decalage de 1 sur la droite
	for(j=1;j<4;j++)
	  {
	    out[4*j+3]=in[4*(j-1)+3];
	  }
	out[3]=in[4*3+3];
}



//  La fonction ShiftRows() decale cycliquement les lignes du bloc message
// de 0,1,2,3 sur la la gauche pour les 1er, 2eme, 3eme, 4eme ligne respectivement
void InvShiftRows(unsigned char *out, unsigned char *in)
{
	int j;
	// la premiere ligne est inchangee
	for(j=0;j<4;j++)
	  {
	    out[4*j]=in[4*j];
	  }
	// deuxieme ligne on decale de 1 sur la gauche 
	for(j=1;j<4;j++)
	  {
	    out[4*j+1]=in[4*(j-1)+1];
	  }
	out[1]=in[4*3+1];
	// troisieme ligne on decale de 2 sur la gauche 
	for(j=0;j<2;j++)
	  {
	    out[4*j+2]=in[4*(j+2)+2];
	    out[4*(j+2)+2]=in[4*(j)+2];
	  }
	//out[4*3+1]=in[1];
	// quatrieme ligne on decale de 1 sur la droite
	for(j=0;j<3;j++)
	  {
	    out[4*j+3]=in[4*(j+1)+3];
	  }
	out[4*3+3]=in[3];
}


// La fonction MixColumns melange les colonnes du bloc de message
void MixColumns(unsigned char *out, unsigned char *in)
{
  int i,j;
  unsigned char Tmp,Tm,t;
  
  for(j=0;j<4;j++)
    {	
      
      Tmp = in[0+j*4] ^ in[1+j*4] ^ in[2+j*4] ^ in[3+j*4] ;
      Tm = in[0+j*4] ^ in[1+j*4] ; 
      Tm = xtime(Tm); 
      out[0+j*4] = Tm ^ Tmp ^  in[0+j*4];
      Tm = in[1+j*4] ^ in[2+j*4] ; 
      Tm = xtime(Tm); 
      out[1+j*4] = Tm ^ Tmp ^ in[1+j*4];
      Tm = in[2+j*4] ^ in[3+j*4] ; 
      Tm = xtime(Tm); 
      out[2+j*4] = Tm ^ Tmp ^ in[2+j*4];
      Tm = in[3+j*4] ^ in[0+j*4]; 
      Tm = xtime(Tm);
      out[3+j*4] = Tm ^ Tmp ^ in[3+j*4];
    }
}


// La fonction MixColumns melange les colonnes du bloc de message
void InvMixColumns(unsigned char *out, unsigned char *in)
{
  int i,j;
  unsigned char Tmp,Tm,t;

  // Reordering the equations we get:
  // y_0  = 0e * x_0 + 0b * x_1 + 0d * x_2 + 09 * x_3 	 
  // y_1  = 0e * x_1 + 0b * x_2 + 0d * x_3 + 09 * x_0 	 
  // y_2  = 0e * x_2 + 0b * x_3 + 0d * x_0 + 09 * x_1 	 
  // y_3  = 0e * x_3 + 0b * x_0 + 0d * x_1 + 09 * x_2.

  for(j=0;j<4;j++)
    {	
      out[0+j*4] = MulE[in[0+j*4]] ^ MulB[in[1+j*4]] ^ MulD[in[2+j*4]] ^ Mul9[in[3+j*4]];
      out[1+j*4] = MulE[in[1+j*4]] ^ MulB[in[2+j*4]] ^ MulD[in[3+j*4]] ^ Mul9[in[0+j*4]];
      out[2+j*4] = MulE[in[2+j*4]] ^ MulB[in[3+j*4]] ^ MulD[in[0+j*4]] ^ Mul9[in[1+j*4]];
      out[3+j*4] = MulE[in[3+j*4]] ^ MulB[in[0+j*4]] ^ MulD[in[1+j*4]] ^ Mul9[in[2+j*4]];
    }

}




// La fonction cipher sert a chiffrer le bloc de message
void Cipher(unsigned char *C, unsigned char M[], unsigned char Key[], int Nr)
{
	int i,j,round=0;
	unsigned char T[16],U[16], V[16],W[16];
	unsigned char RoundKey[240];

	//On fabrique les clefs de ronde
	KeyExpansion( RoundKey, Key, 10);


	//On copide le messge dans le bloc d'etat 
	for(i=0;i<4;i++)
	{
		for(j=0;j<4;j++)
		{
			W[4*j+i] = M[4*j + i];
		}
	}


//    for (i=0; i<4;i++) {
//        for (j=16; j<24; j++) {
//            if (!(j%4))
//                printf("  ");    
//            printf("%02x ", RoundKey[j*4 + i]);
//        }
//        printf("\n");
//    }

    //printf("\n");

	// AddKey de la premiere clef
	AddRoundKey(T,W,RoundKey,0); 

	// Il y a Nr rondes.
	// Les Nr-1 premieres rondes sont identiques
	// Ces Nr-1 rondes sont effectuées dans la boucle for ci-dessous
	for(round=1;round<Nr;round++)
	{
	  SubBytes(U,T);
	  ShiftRows(V,U);
	  MixColumns(W,V);
	  AddRoundKey(T,W,RoundKey,round);
	}	
	// Derniere ronde
	// La fonction MixColumns n'est pas dans la derniere ronde
	SubBytes(U,T);
	ShiftRows(V,U);
	AddRoundKey(W,V,RoundKey,Nr);


	// Le processus de chiffremen est fini
	// On copie le bloc d'etat du message dans le bloc de message chiffre
	for(i=0;i<4;i++)
	{
		for(j=0;j<4;j++)
		{
			C[j*4+i]=W[4*j+i];
		}
	}
}


// Manque une fonction de dechiffrement
void Decipher(unsigned char *out, unsigned char in[], unsigned char Key[], int Nr)
{

	int i,j,round=0;
	unsigned char T[16],U[16], V[16],W[16];
	unsigned char RoundKey[240];

	//On fabrique les clefs de ronde
	KeyExpansion( RoundKey, Key, 10);

	//On copide le messge dans le bloc d'etat 
	for(i=0;i<4;i++)
	{
		for(j=0;j<4;j++)
		{
			W[4*j+i] = in[4*j + i];
		}
	}

	// On "pele" derniere ronde
	// La fonction MixColumns n'est pas dans la derniere ronde
	AddRoundKey(V,W,RoundKey,Nr);
	InvShiftRows(U,V);
	InvSubBytes(T,U);


	// Il y a Nr rondes.
	// Les Nr-1 premieres rondes sont identiques
	// Ces Nr-1 rondes sont dechiffrees dans la boucle for ci-dessous
	for(round=Nr-1;round>0;round--)
	{
	  AddRoundKey(W,T,RoundKey,round);
	  InvMixColumns(V,W);
	  InvShiftRows(U,V);
	  InvSubBytes(T,U);

	}	

	// AddKey de la premiere clef
	AddRoundKey(W,T,RoundKey,0); 

	// Le processus de dechiffremen est fini
	// On copie le bloc d'etat du message dans le bloc de message clair (out)
	for(i=0;i<4;i++)
	{
		for(j=0;j<4;j++)
		{
			out[j*4+i]=W[4*j+i];
		}
	}
}

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  EnxpandKeyInv
 *  Description:  
 * =====================================================================================
 */
void ExpandKeyInv(unsigned char *res, unsigned char *rKey, int tour) {
	unsigned char tmp[16] = {0};
    unsigned int i, j;
    if (tour == 1)
        Affecte(res, rKey);
    else {
        // Trois dernières colonnes de la clé de ronde précédente
        for (i=3; i>0; i--) 
            for (j=0; j<4; j++)
                tmp[i*4 + j] = rKey[i*4 + j] ^ rKey[(i-1)*4 + j];
        // Première colonne de la clé de reonde précédente
        // RotWord
        unsigned char tmp_col[4];
        tmp_col[0] = tmp[13];
        tmp_col[1] = tmp[14];
        tmp_col[2] = tmp[15];
        tmp_col[3] = tmp[12];
        // SubBytes
        for (i=0; i<4; i++)
            tmp_col[i] = sbox[tmp_col[i]]; 

        tmp[0] = tmp_col[0] ^ tmp[4] ^ Rcon[tour];
        for (i=1; i<4; i++) 
            tmp[i] = tmp_col[i] ^ tmp[4+i];

        Affecte(res, tmp);
    }
}		/* -----  end of function EnxpandKeyInv  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  main
 *  Description:  
 * =====================================================================================
 */
int main(int argc, char **argv) {
    // Compteurs
    unsigned int i, j, k;
    // Clé de chiffrement
    unsigned char K[] = {0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c};
    // Clé de déchiffrement
    unsigned char DK[16] = {0};
    unsigned char Ksol[16] = {0};
    // Ensemble des messages
    unsigned char **M = (unsigned char **) calloc (256, sizeof(unsigned char *));
    unsigned char **C = (unsigned char **) calloc (256, sizeof(unsigned char *));
    unsigned char **M2 = (unsigned char **) calloc (256, sizeof(unsigned char *));
    unsigned char **C2 = (unsigned char **) calloc (256, sizeof(unsigned char *));
    // Somme
    unsigned char SUM[16] = {0};
    unsigned char *T = (unsigned char *) calloc (16, sizeof(unsigned char *));
    unsigned char *T2 = (unsigned char *) calloc (16, sizeof(unsigned char *));

    // Allocation de mémoire
    for (i=0; i<256; i++) {
        M[i] = (unsigned char *) calloc (16, sizeof(unsigned char));
        C[i] = (unsigned char *) calloc (16, sizeof(unsigned char));
        M2[i] = (unsigned char *) calloc (16, sizeof(unsigned char));
        C2[i] = (unsigned char *) calloc (16, sizeof(unsigned char));
        // Saturation d'un octet
        M[i][0] = i;
        M2[i][7] = i;
        // Octet fixe
        M[i][1] = 0x23;
        M[i][2] = 0x54;
        M[i][3] = 0x26;
        M[i][4] = 0xc7;
        M[i][5] = 0x29;
        M[i][6] = 0x2b;
        M[i][7] = 0x2c;
        M[i][8] = 0x2d;
        M[i][9] = 0x4f;
        M2[i][7] = 0xf2;
        M2[i][8] = 0xe5;
        M2[i][9] = 0xa2;
        M2[i][10] = 0x02;
        M2[i][11] = 0x63;
        M2[i][12] = 0xf8;
        M2[i][13] = 0x3d;
        M2[i][14] = 0xf4;
        M2[i][15] = 0x85;
    }

    // Crypter les messages (4 tours)
    for (i=0; i<256; i++) {
        Cipher(C[i], M[i], K, 4);
        Cipher(C2[i], M2[i], K, 4);
        //affichage_tableau4par4(C[i]);
        //affichage_tableau4par4(C2[i]);
    }
    // Attaque de la clé octet par octet
    // NOTE : Pour attaquer la clé il n'y a à prioris pas besoin de faire l'opération de ShiftRow vu
    // qu'elle ne fait que déplacer un octet, elle ne change pas la valeur de la somme.

    // Les 16 octets de la clé
    for (i=0; i<16; i++) {
        // Les 256 valeurs possibles de l'octet
        for (k=0; k<256; k++) {
            DK[i] = k;
            // Les 256 messages
            for (j=0; j<256; j++) {
                unsigned char t1, t2;
                t1 = DK[i]^C[j][i];
                t2 = DK[i]^C2[j][i];
                t1 = sboxinv[t1];
                t2 = sboxinv[t2];
                T[i] = T[i]^t1;
                T2[i] = T2[i]^t2;
            }
            if (T[i]==0 && T2[i]==0) 
                break;
            
            if (k == 255)
                printf("Bordel de merde!\n");
        }
    }

    printf("XOR de tous les messages après ajout de la clé (1e série):\n");
    affichage_tableau4par4(T);
    printf("XOR de tous les messages après ajout de la clé (2e série):\n");
    affichage_tableau4par4(T2);

    printf("Clé de la dernière ronde (fausse pour l'instant) :\n");
    affichage_tableau4par4(DK);

    for (i=4; i>0; i--) {
        ExpandKeyInv(Ksol, DK, i);
        Affecte(DK, Ksol);
    }

    printf("Clé de chiffrement utilisée :\n");
    affichage_tableau4par4(K);
    printf("Clé de chiffrement trouvée (fausse pour l'instant) :\n");
    affichage_tableau4par4(Ksol);

    // Libération de mémoire
    for (i=0; i<256; i++) {
        free(M[i]);
        free(C[i]);
        free(M2[i]);
        free(C2[i]);
    }

    free(M);
    free(C);
    free(T);
    free(M2);
    free(C2);
    free(T2);
    
	return EXIT_SUCCESS;
}				/* ----------  end of function main  ---------- */

